= Курсовая работа
:description: Лабораторная работа 9
:toc: 
:toclevels: 4
:toc-title: Оглавление
:sectnums: |,all|
:stem: latexmath
:figure-caption: Рисунок
:imagesdir: PIC
:table-caption: Таблица

include::Tityale_kursovoi.adoc[]
include::Annotation_kursovoi.adoc[]

== ВВЕДЕНИЕ

== Требования к разработке ПО

=== Общие положения

Программное обеспечение предназначено для микроконтроллерной системы мониторинга вибрации, основанной на *STM32F411RE*. В системе используется трёхосевой аналоговый акселерометр *ADXL337*, модуль *Bluetooth HC-06* для беспроводной передачи данных, а также плата расширения *Accessory Shield*. Разработка ведётся в среде *IAR Embedded Workbench for ARM ver. 9.10.2*.

Цель системы - организация сбора, обработки и передачи данных о вибрации в реальном времени с возможностью раннего обнаружения неисправностей, таких как износ подшипников в насосном оборудовании (например, Wilo Stratos или Grundfos MAGNA).

=== Основные задачи программного обеспечения

* Инициализация встроенных периферийных модулей STM32:
** АЦП (инжекторные каналы для X, Y, Z)
** Таймеров
** UART (связь с HC-06)
* Считывание аналоговых сигналов от акселерометра *ADXL337* по трём осям через *инжекторные каналы* АЦП
* Измерение *напряжения питания системы (Vcc)* через отдельный канал АЦП
* Пересчёт значений АЦП в напряжение, затем — в ускорение с учётом измеренного значения Vcc
* Формирование пакета данных с тремя ускорениями (Ax, Ay, Az) и его передача через UART → HC-06 → ПК/смартфон
* Установка *порогового значения ускорения*, при превышении которого программно генерируется *предупреждение* о возможной неисправности

=== Принцип работы системы

==== Сбор данных

* ADXL337 подключается к трём *инжекторным каналам* АЦП STM32: X, Y, Z
* Один дополнительный канал АЦП используется для измерения *напряжения питания (Vcc)*, поступающего на акселерометр
* Диапазон выходного сигнала ADXL337: *от 0 до Vcc*
** Опорное напряжение, соответствующее 0 g = Vcc / 2

==== Оцифровка и обработка

* Используется *12-битный АЦП STM32* (диапазон значений 0-4095)
* Перевод значения АЦП в напряжение:

[latexmath]
++++
V = \frac{\text{ADC_value}}{4095.0} \cdot V_{cc}
++++

* Перевод напряжения в ускорение (по каждой оси):

[latexmath]
++++
A = \frac{V - \left(\frac{V_{cc}}{2}\right)}{0.330}
++++


* Расчёты выполняются для всех трёх осей: X, Y, Z

==== Передача данных

Значения ускорений по трём осям (Ax, Ay, Az), вычисленные на основе сигналов от акселерометра ADXL337, **объединяются в структурированный пакет данных**, который далее передаётся по UART в модуль Bluetooth *HC-06* и поступает на устройство-приёмник (смартфон, ПК и т.п.).

Формат передаваемого пакета выбирается таким образом, чтобы обеспечить:

- читаемость на принимающей стороне;
- возможность последующего анализа и визуализации;
- устойчивость к ошибкам передачи (по возможности — добавление контрольной суммы).

==== Структура пакета

Формат пакета может быть строковым, в виде ASCII-последовательности, например:

[source,text]
----
<AX:+0.12;AY:-0.03;AZ:+1.01;>
----

Пояснение:
- Каждое значение ускорения сопровождается идентификатором оси (`AX`, `AY`, `AZ`)
- Значения представлены с фиксированной точкой, например, `+0.12` (в единицах g)
- Пакет начинается символом `<` и заканчивается `>` — это позволяет надёжно определять границы пакета на принимающей стороне
- Разделитель `;` между параметрами обеспечивает удобный парсинг строки

*Особенности передачи*

* Период отправки пакета определяется таймером (например, 10 Гц).
* Передача осуществляется в основном цикле или по прерыванию.
* Возможна реализация обратной связи — например, подтверждение приёма пакета от устройства или приём команд управления с ПК.

*Применение на приёмной стороне*

На устройстве-приёмнике (ПК или смартфон):
- данные принимаются через Bluetooth COM-порт;
- парсятся по символам начала и конца (`<`, `>`);
- значения визуализируются в виде графиков или таблиц в реальном времени;
- при превышении установленного порога по любой из осей генерируется тревожное сообщение или сигнал операторам.

=== Применение в реальных системах

Система ориентирована на предиктивный мониторинг насосов, таких как *Grundfos MAGNA*, *Wilo Stratos* и др. Эти насосы содержат ротор, вращающийся на высокой скорости, и малейшие отклонения по вибрации могут указывать на:

* износ подшипников
* дисбаланс крыльчатки
* кавитацию

Использование акселерометра *ADXL337* позволяет:
- в реальном времени отслеживать уровень вибраций
- диагностировать отклонения от нормы
- предотвращать аварийную остановку оборудования

Данные визуализируются на устройстве пользователя в виде графика, и при выходе за допустимые пределы система выдает *предупреждение*.

=== Интерфейсы и взаимодействие с оборудованием

[cols="1,1,1", options="header"]
|===
| Устройство | Назначение | Подключение к STM32

| ADXL337
| Измерение вибраций
| ADC1_IN0 (X), ADC1_IN1 (Y), ADC1_IN2 (Z) через инжекторные каналы

| Канал Vcc
| Измерение опорного напряжения
| ADC1_IN3

| HC-06
| Передача данных по Bluetooth
| UART2 (TX, RX)

| Accessory Shield
| Плата расширения для подключения датчиков
| Пины АЦП и UART STM32

| ST-Link/V2
| Отладка и прошивка
| SWD-интерфейс

| IAR Embedded Workbench
| Среда разработки и компиляции ПО
| Используется для прошивки и отладки
|===

== Анализ требований ПО

=== Отладочная плата XNUCLEO-F411RE

*XNUCLEO-F411RE* (рисунок 1) — это отладочная плата, разработанная компанией *STMicroelectronics*, построенная на микроконтроллере *STM32F411RET6* семейства *ARM Cortex-M4*. Плата предназначена для быстрого прототипирования и тестирования встроенных решений. Оснащена встроенным программатором/отладчиком *ST-LINK/V2-1* и поддерживает как стандарт *Arduino Uno R3*, так и фирменный *ST Morpho*.

.Отладочная плата XNUCLEO-F411RE
image::Отладочная плата.jpg[]

*Архитектурные особенности*

Микроконтроллер *STM32F411RET6* реализует 32-битную гарвардскую архитектуру, что означает разделение шин данных и инструкций. Ядро *Cortex-M4F* оснащено аппаратным блоком вычислений с плавающей точкой (FPU), что делает плату особенно подходящей для задач цифровой обработки сигналов, сенсорных систем и управления в реальном времени.

*Технические характеристики*

[cols="1,1", options="header"]
|===
| Параметр | Значение

| Ядро процессора
| ARM Cortex-M4 с FPU

| Частота работы
| до 100 МГц

| Объём Flash памяти
| 512 КБ

| Объём SRAM
| 128 КБ

| Количество линий ввода/вывода
| до 50 (многофункциональные)

| Таймеры
| 10 (включая PWM, таймеры общего назначения, системные таймеры, таймер для TRGO)

| Аналоговые интерфейсы
| 12-битный АЦП (до 16 каналов), поддержка инжекторного режима

| Цифровые интерфейсы
| UART, USART, I2C, SPI, USB OTG FS

| Отладка
| Встроенный ST-LINK/V2-1 через SWD интерфейс

| Совместимость
| Arduino Uno R3, ST Morpho

| Источники питания
| от USB (5 В) / внешнее (7–12 В через VIN) / программный выбор через джамперы

| Напряжение логики
| 3.3 В (встроенный стабилизатор)
|===

*Аппаратные возможности*

* Поддержка подключения Arduino-совместимых шилдов
* Разъёмы ST Morpho предоставляют доступ ко всем GPIO, включая ADC, UART и TIM
* Встроенный ST-LINK/V2-1 позволяет загружать прошивки и отлаживать ПО без внешних программаторов
* Светодиоды состояния (PWR, LD1, LD2, LD3)
* Пользовательская кнопка (B1) и LED (LD2)
* Быстрый выбор источников питания (USB, VIN) и соединений (ST-LINK/UART) через джамперы

*Питание*

Питание отладочной платы может быть организовано тремя способами:

* Через *MicroUSB* кабель (от ПК или блока питания 5 В)
* Через внешний источник питания 7–12 В (подаётся на пин *VIN* или коннектор *E5V*)
* От внешнего стабилизированного источника 3.3 В (на пин *3V3*, при отключённом внутреннем LDO)

Питание периферии осуществляется от встроенного стабилизатора 3.3 В. Источник питания выбирается автоматически либо настраивается вручную с помощью джамперов `JP5`, `JP1`.

*Преимущества при разработке*

Плата *XNUCLEO-F411RE* идеально подходит для построения систем сбора данных и анализа вибрации:

* Совместима с библиотеками *STM32Cube HAL* и *LL*
* Поддерживает работу с инжекторными каналами АЦП
* Обеспечивает стабильную работу UART и таймеров для запуска TRGO
* Удобный доступ к аналоговым и цифровым входам (PA0–PA3, PA2/PA3 для UART2)
* Совместимость с программой отладки в *IAR Embedded Workbench* и *STM32CubeIDE*

*Применение в проекте*

Плата применяется как основа микроконтроллерной части системы мониторинга вибрации. Благодаря встроенному АЦП, UART и таймерам, она обеспечивает:

* считывание данных с акселерометра ADXL337,
* точную синхронизацию измерений (через TIM → TRGO → инж. АЦП),
* передачу данных через Bluetooth (HC-06),
* реализацию предиктивной диагностики в реальном времени.

====
STM32F411RET6 демонстрирует оптимальное сочетание производительности, гибкости и энергоэффективности, необходимое для задач анализа вибрации и построения интеллектуальных сенсорных систем.
====

=== Настройка АЦП (аналогово-цифрового преобразователя)

АЦП используется для получения аналоговых сигналов от акселерометра *ADXL337*, подключенного по трём осям (X, Y, Z), а также для измерения напряжения питания *Vcc*. Для синхронного и точного замера используется **инжекторный режим** работы АЦП.

==== Назначение

Измерения выполняются с использованием инжекторных каналов АЦП, так как они:

* Позволяют запускать оцифровку по внешнему триггеру (от таймера)
* Обеспечивают приоритетный и синхронный захват данных
* Могут использовать до 4 последовательных инжекторных каналов

==== Используемые каналы и выводы

[cols="1,1,1", options="header"]
|===
| Назначение         | Канал ADC             | Пин STM32F411RE

| ADXL337 X
| ADC1_IN0 (Injected Rank 1)
| PA0

| ADXL337 Y
| ADC1_IN1 (Injected Rank 2)
| PA1

| ADXL337 Z
| ADC1_IN2 (Injected Rank 3)
| PA2

| Напряжение питания Vcc
| ADC1_IN3 (Injected Rank 4)
| PA3
|===

==== Подробная настройка режима АЦП

АЦП работает в **инжекторном режиме с внешним триггером**, запускаемом по событию *TRGO* от таймера TIM2.

==== Конфигурация:

* Разрешение: 12 бит
* Напряжение опорное: Vref = 3.3 В
* Выравнивание данных: правое
* Количество инж. каналов: 4 (X, Y, Z, Vcc)
* Частота опроса: 10 Гц
* Время выборки: `ADC_SAMPLETIME_84CYCLES`

==== Пример конфигурации (HAL)

[source,c]
----
ADC_HandleTypeDef hadc1;
ADC_InjectionConfTypeDef sInjected;

hadc1.Instance = ADC1;
hadc1.Init.Resolution = ADC_RESOLUTION_12B;
hadc1.Init.ScanConvMode = ENABLE;
hadc1.Init.ContinuousConvMode = DISABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 1;
HAL_ADC_Init(&hadc1);
----

Настройка инжекторных каналов (пример для X):

[source,c]
----
sInjected.InjectedChannel = ADC_CHANNEL_0; // PA0
sInjected.InjectedRank = ADC_INJECTED_RANK_1;
sInjected.InjectedNbrOfConversion = 4;
sInjected.InjectedSamplingTime = ADC_SAMPLETIME_84CYCLES;
sInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_RISING;
sInjected.ExternalTrigInjecConv = ADC_EXTERNALTRIGINJECCONV_T2_TRGO;
HAL_ADCEx_InjectedConfigChannel(&hadc1, &sInjected);
----

Аналогично настраиваются `ADC_CHANNEL_1`, `ADC_CHANNEL_2`, `ADC_CHANNEL_3`.

==== Регистрирующая логика

* Запуск по триггеру: `TIM2_TRGO → ADC1_JSQR`
* Данные сохраняются в `JDR1`–`JDR4` (регистр данных инжекторных каналов)
* Обработка значений — вручную в главном цикле или по прерыванию

=== Настройка таймера TIM2 (организация дискретизации)

Таймер `TIM2` используется для создания события TRGO, запускающего АЦП в инжекторном режиме.

==== Параметры:

* Источник тактирования: APB1 (84 МГц)
* Целевая частота: 10 Гц
* Prescaler = 8399 → 10 кГц
* Period = 999 → 10 Гц (один "тик" = 0.1 с)
* Мастер-триггер: `TRGO = Update Event`

==== Конфигурация HAL

[source,c]
----
htim2.Instance = TIM2;
htim2.Init.Prescaler = 8399;
htim2.Init.Period = 999;
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
HAL_TIM_Base_Init(&htim2);

TIM_MasterConfigTypeDef sMasterConfig = {0};
sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);

HAL_TIM_Base_Start(&htim2);
----

TIM2 будет каждые 100 мс генерировать сигнал, который запускает АЦП.

---

=== Передача значений по беспроводному интерфейсу должна осуществляться через модуль BlueTooth Bee HC–06.

Bluetooth – открытый стандарт беспроводной связи с низким энергопотреблением, обеспечивающий передачу данных и звука между совместимыми устройствами.

В качестве модуля будет использован – Bluetooth Bee HC–06 (рисунок 2)– это недорогой и широко используемый модуль Bluetooth, предназначенный для беспроводной передачи данных между микроконтроллером (например, Arduino или STM32) и другим Bluetooth-устройством (смартфоном, ПК и т.д.). Модуль работает по стандарту Bluetooth 2.0 + EDR и поддерживает только режим Slave, то есть не может сам инициировать соединение, а только принимать его.

.Модуль Bluetooth Bee HC-06
image::Модуль Bluetooth Bee HC-06.jpg[]

Модуль имеет стандартный последовательный интерфейс UART, благодаря чему легко интегрируется в любые встраиваемые системы. HC-06 выпускается также в форм-факторе Bee, совместимом с разъёмами XBee-модулей (например, для плат расширения Arduino XBee Shield).

[cols="1,2", options="header"]
|===
| Параметр | Значение

| Модель
| HC-06 (Bee формат)

| Версия Bluetooth
| 2.0 + EDR (Enhanced Data Rate)

| Режим работы
| Только Slave

| Интерфейс подключения
| UART (TX, RX), уровень логики: 3.3 В

| Скорость передачи данных UART
| 9600 бод по умолчанию (диапазон настройки: 1200–1382400 бод)

| Рабочее напряжение питания
| 3.3 В – 6 В (обычно 5 В, логика 3.3 В)

| Выходная мощность
| До +4 дБм

| Дальность действия
| До 10 метров

| Рабочая частота
| 2.4 ГГц (ISM диапазон)

| Поддерживаемые профили
| SPP (Serial Port Profile)

| Антенна
| Встроенная печатная антенна

| Совместимость
| Android, Windows, STM32, Arduino и др.

| AT-команды
| Доступны только в незапаренном состоянии

| Размеры модуля
| Около 24 мм × 14 мм × 2 мм
|===

Для подключения модуля BlueTooth должна использоваться плата Accessories Shield.

==== Плата расширения Accessory Shield

*Accessory Shield* (рисунок 3) — это универсальная плата расширения, разработанная для упрощения прототипирования и разработки электронных устройств. Она совместима с популярными микроконтроллерными платформами, включая *Arduino UNO*, *Arduino Leonardo*, *STM32 NUCLEO*, *XNUCLEO*, а также с другими совместимыми отладочными платами.

Данная плата позволяет разработчику сразу приступить к созданию приложений, минуя этапы ручной сборки схем — все основные модули и сенсоры уже распаяны и готовы к использованию.

.Плата расширения Accessory Shield
image::Плата расширения Accessory Shield.png[]

*Назначение и возможности*

Accessory Shield представляет собой удобный инструмент для быстрого подключения и тестирования различных периферийных компонентов. Это особенно полезно в образовательных целях, при создании прототипов, а также на этапе тестирования функций и взаимодействий встраиваемой системы.

*Основные модули на плате*

[cols="1,2", options="header"]
|===
| Компонент | Назначение

| Светодиоды (LED)
| Индикация состояния, отладка логики

| Кнопки
| Пользовательский ввод, взаимодействие с системой

| Фоторезистор (LDR)
| Измерение освещённости

| Датчик температуры (NTC)
| Простое измерение температуры окружающей среды

| Пьезоизлучатель
| Генерация звуковых сигналов

| ИК-приёмник
| Приём сигналов от ИК-пульта управления

| Потенциометр
| Аналоговый ввод (например, управление яркостью, частотой и т.п.)

| Гнёзда для подключения внешних устройств
| Расширение функционала через стандартные интерфейсы
|===

*Электрическая и механическая совместимость*

Accessory Shield имеет стандартное расположение контактов Arduino Uno, что делает её полностью совместимой со следующими платформами:

* Arduino Uno / Leonardo
* STM32 NUCLEO / XNUCLEO с Arduino-разъёмами
* Другие платы с аналогичной разводкой

Щиток подключается напрямую к основной плате через стандартные гребёнки и не требует дополнительных переходников или модификаций.

*Преимущества использования*

* Все основные элементы уже интегрированы и готовы к использованию
* Значительно ускоряет процесс отладки и тестирования
* Подходит для обучения и демонстрации принципов работы датчиков и интерфейсов
* Не требует пайки — все подключения выполнены через контактные разъёмы
* Удобно совмещается с библиотеками Arduino или STM32Cube (через HAL/LL)

*Области применения*

* Учебные лаборатории и курсы по микроконтроллерам
* Быстрое прототипирование пользовательских интерфейсов
* Тестирование алгоритмов обработки данных от сенсоров
* Демонстрационные проекты и DIY-платформы

====
Accessory Shield может использоваться как в простых демонстрационных задачах, так и в качестве базы для более сложных проектов, требующих взаимодействия с датчиками и элементами управления.
====

=== Инициализация UART и модуля BlueTooth Bee HC–06

==== Назначение

Передача данных осуществляется через UART-интерфейс STM32. К нему подключён модуль *HC-06*, который передаёт значения ускорений и сигналы тревоги на внешний приёмник (ПК или смартфон).

==== Аппаратная реализация

[cols="1,1,1", options="header"]
|===
| Назначение     | Модуль STM32        | Пин

| UART TX
| USART2_TX
| PA2

| UART RX
| USART2_RX
| PA3
|===

Модуль *HC-06* работает на стандартной скорости 9600 бод.

==== Конфигурация UART

[source,c]
----
huart2.Instance = USART2;
huart2.Init.BaudRate = 9600;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
HAL_UART_Init(&huart2);
----

Далее данные передаются функцией `HAL_UART_Transmit()` в виде текстовых пакетов.

==== Пример передачи данных

[source,c]
----
char buffer[64];
snprintf(buffer, sizeof(buffer),
         "<AX:%.2f;AY:%.2f;AZ:%.2f;>", ax, ay, az);
HAL_UART_Transmit(&huart2, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
----

В случае превышения порога можно передавать отдельное сообщение тревоги:

[source,text]
----
<ALERT:VIBRATION EXCEEDED;A=0.51;>
----

=== ПО должно измерять ускорение по трем осям, и переводить значения в напряжение

==== Контроль порогового значения вибрации

Программно реализуется возможность задания *порогового значения виброускорения* для анализа технического состояния оборудования. При превышении порога система формирует *предупреждение*.

==== Физический смысл и значение

Виброускорение выше ~0.4 g (гравитационных единиц) может свидетельствовать об износе подшипников, дисбалансе ротора или кавитации. Это значение принято в практике для насосов типа *Wilo Stratos* и *Grundfos MAGNA*.

==== Расчёт и условие

Сначала рассчитывается результирующее ускорение:

[latexmath]
++++
A_{\text{total}} = \sqrt{A_x^2 + A_y^2 + A_z^2}
++++


Затем сравнивается с порогом (например, `0.4f`):

[source,c]
----
if (A_total > 0.4f) {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET); // включение сигнала
    send_alert("VIBRATION EXCEEDED", A_total);          // передача тревоги
}
----

=== Логическое ядро работы системы

Ядро представляет собой цикл опроса данных, анализа, и передачи. События синхронизируются по таймеру.

==== Основной алгоритм

. Инициализация: ADC, TIM2, UART, GPIO
. Запуск TIM2, связанного с TRGO
. В прерывании таймера или главном цикле:

* Старт инжекторного преобразования
* Ожидание завершения (Polling или Callback)
* Чтение значений из `HAL_ADCEx_InjectedGetValue(...)`
* Перевод в напряжения и ускорения:

[latexmath]
++++
V = \frac{\text{ADC}}{4095.0} \cdot V_{cc}
++++

* Расчёт общего ускорения:

[latexmath]
++++
A = \frac{V - \left(\frac{V_{cc}}{2}\right)}{0.330}
++++

Итоговая формула:

[latexmath]
++++
A = \frac{\left(\frac{\text{ADC}}{4095.0} \cdot V_{cc}\right) - \left(\frac{V_{cc}}{2}\right)}{0.330}
++++

* Сравнение с порогом:

[source,c]
----
float ax = ...; // вычислено ранее из ADC X
float ay = ...; // вычислено ранее из ADC Y
float az = ...; // вычислено ранее из ADC Z

// Расчёт общего ускорения по модулю
float A_total = sqrt(ax * ax + ay * ay + az * az);

// Проверка на превышение порога
if (A_total > THRESHOLD) {
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET); // Включить тревожный светодиод
    send_alert(); // Передача тревожного пакета через UART/Bluetooth
}
----

* Формирование пакета и передача через UART

==== Преимущества архитектуры

* Полностью управляемая частота опроса
* Высокая точность за счёт синхронных инжекторных замеров
* Простая интеграция с внешними системами (Bluetooth, графики)

==== Уведомление

При срабатывании порогового контроля:
* Включается тревожный индикатор (LED)
* Отправляется предупреждающий пакет вида:

[source,text]
----
<ALERT:VIBRATION EXCEEDED;A=0.52;>
----

* Данные визуализируются на ПК или смартфоне\


== Разработка архитектуры в виде UML диаграмм 


== Код программы
